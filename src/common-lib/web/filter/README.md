<p align="center">
<img height=70px src="docs/images/logo.png">
<img height=70px src="docs/images/Go-Logo_Blue.png">
</p>

# REST Filter

This is a REST filter handler implementation which can be used as a middleware or without it. This implementation follows the strategy pattern. New staregies can be defined to parse an input filter. As of now, it's just token-based, tree based can also be added.

The requirements can be found here: https://confluence.kksharmadevdev.com/x/YVBeBw

The algorithmic approach can be found here: https://confluence.kksharmadevdev.com/x/lKjyBw

Lucidchart link for UML: https://lucid.app/lucidchart/invitations/accept/acd0fcad-ee1f-411c-8f48-cd41c3fff2cd

Lucidchart link for interaction diagram: https://lucid.app/lucidchart/invitations/accept/edd03b2c-744b-4277-8024-45d88a356707

Alternatively, the lucid charts are added to wiki here: https://confluence.kksharmadevdev.com/x/ajYuC


### Third-Party Libraties

None

### Internal Packages

```go
// Package tokenize implements a token based strategy that can be used
// to parse the a query filter and generate a Filter which consists of
// a query and a value as generated by the supplied Converter.
package tokenize

// Package filter houses the logic to handle
// complex filter in REST query parameter.
package filter
```

### Types
```go

//TokenStrategy : a strategy to get sql from filter using tokenization
type TokenStrategy struct {
}

// HandlerFunc : A type representing rest filter handler.
type HandlerFunc func(http.ResponseWriter, *http.Request, Strategy, command.Converter, func(string) string) (*http.Request, error)
```

### Interfaces
```go
// Strategy : A strategy to parse a filter query
type Strategy interface {
	Parse(cnv command.Converter, query string, mapper func(string) string) (*filter.Filter, error)
}
```

**Whitelisted Field Mapper**
The Strategy Parse method expects a mapper function to be passed in. This mapper should look up a map
of json field names that a caller sees in the response versus the corresponding column name in the DB.

Fileds parse in the query are looked up in the mapper and the parsing succeeds only if all the fields are found. 
Hence, the mapper provides a way to whitelist what all DB fields can be queried upon. 

**Supported Operators**
Check the src/filter/command package to get the list of supported operators.

**Middleware**
A middleware function is available in the filter package: filter.Middleware
Wrapping your handler with this middleware will enable rest filtering on that handler. The middleware takes care
of parsing the query param filter and coverting that into a src/filter.Filter struct which then gets marshalled
and added as a request header.

**Helper functions to read/write filter from/to http.Request context**
The src/web/filter package provides a helper function to extract the filter from request context.

```go
// SetRequestContext : sets the filter into HTTP request context.
func SetRequestContext(f *filter.Filter, req *http.Request) *http.Request

// GetFilter : helps get filter from request context.
func GetFilter(req *http.Request) (*filter.Filter, error)
```

**A test handler**
```go
/*
A test handler to be wrapped with advanced filter handling. This mimics an actual API handler.
We're reading the restfilter output from the request header and using it in the db query.
*/
//testHandler : A test handler to be wrapped with advanced filter handling.
func testHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Printf("Middleware: Request headers with query: %v\n", r.Header)

	partnerID := 123
	query := getTicketsByPartnerIDSQL

	//Getting restfilter output from request header.
	f, _ := filter.GetFilter(r)

	//Appending the putput to the where clause of the query.
	query, vals := sql.AppendFilterToWhereClause(getTicketsByPartnerIDSQL, f, 2, []interface{}{partnerID})

	//setting up a mock db.
	db, mock, err := sqlmock.New()
	if err != nil {
		panic(err)
	}
	defer db.Close()

	//setting query expectations.
	mock.ExpectQuery(regexp.QuoteMeta(expectedSQL)).WithArgs(123, "%critical%", "%emergency%", "New", "InProgress").WillReturnRows(nil)

	//prepared statment call with the query and vals.
	_, err = db.Query(query, vals...)
	if err != nil {
		panic(err)
	}

	//asserting the expectation.
	if err = mock.ExpectationsWereMet(); err != nil {
		panic(fmt.Sprintf("there were unfulfilled expectations: %s", err))
	}
}
```

**An error handler**
```go
/*
The rest filter middleware is capable of returning errors. As such, we need to define a custom handler/interceptor  which accept the intended handler and the rest filter
middleware as inputs. This interceptor will handle the rest filter middleware error and accordingly decide whether to invoke the intended handler or return the error.
One such handler need to be defined to work with all the entity specific handlers you have in the repo.
*/
func restFilterErrorHandler(r *http.Request, next http.HandlerFunc, hdlr restfilter.HandlerFunc, callback converters.ConvertToField) web.HTTPHandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		if err := hdlr(w, req, callback); err != nil {
			fmt.Printf("Middleware: Error: %v\n", err.Error())
			return
		}
		next(w, req)
	}
}
```

**Advanced filter handling as a middlware**
```go
/*
Demonstrates how the rest filter handler has to be used as a midlleware.
*/
func asMiddleware(u string) {
	r, _ := http.NewRequest(http.MethodGet, u, nil)
	restFilterErrorHandler(r, testHandler, restfilter.Middleware, convertToSQLField)(nil, r)
}
```
**Advanced filter handling without a middleware**
```go
/*
Demonstrates how the rest filter handler can be used without the middleware.
Steps:
  1. Instantiate a strategy to be used. Right now, it's just Token-Based (will also add BinaryTree-Based in future).
  2. Instantiate a converter. Right now, it's just SQL converter(more converters can be added in future).
  3. Call strategy parse method, passing the converter to it. Need to pass the whitelisting mapper 
  to parse method.
*/
func noMiddleware(u string) {
	res, _ := url.ParseQuery(u)
	filter := string(res.Get("https://ticket-service/v1/tickets?filter"))

	start := time.Now()
	ts := strategies.GetTokenStrategy()
	cnv := sql.GetConverter()
	f, err := ts.Parse(cnv, filter, convertToSQLField)
	elapsed := time.Since(start)
	if err != nil {
		fmt.Printf("Filter syntax error: %v\nFilter: %v\n", err, filter)
	}
	fmt.Printf("Time taken: %s\n", elapsed)
	fmt.Printf("NoMiddleware: %v\n", f)
}
```
**An input query filter**
```go
/*
Demonstrates how an input query filter looks like.
*/
```go
func main() {
	u := `https://ticket-service/v1/tickets?filter=(summary : "critical" OR summary : "emergency") AND (status = "New" OR status = "InProgress")`
	noMiddleware(u)
	asMiddleware(u)
}
```
**Append Output to SQL Query**
```go
package converters
//AppendOutputToWhereClause : appends the output to SQL query where clause
func AppendFilterToWhereClause(query string, f filter.Filter, start int) string
```

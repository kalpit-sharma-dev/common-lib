<p align="center">
<img height=70px src="docs/images/logo.png">
<img height=70px src="docs/images/Go-Logo_Blue.png">
</p>

# REST Pagination

This library provides support for REST pagination. This uses the key-set pagination technique where in the API callers needs to provide a - limit, cursor and sortBy. The library uses common-lib src/filter package internally to transform the pagination criteria into a sql clause.

The requirements can be found here: https://confluence.kksharmadevdev.com/x/YVBeBw

### Third-Party Libraties

None

### Internal Packages

```go
// Package tokenize comprises a token based strategy that can be used
// to parse the a query filter and generate a Filter which consists of
// a query and a value as generated by the supplied Converter.
package pagination
```

### Types
```go
// PaginationParams is the struct defining the params expected for pagination
type PaginationParams struct {
	// No. of records to fetch per page
	Limit   int
	// The last record that was fetched, and where to start teh next page from 
	Cursor string
	// Set this if the caller wants to have a custom sorting on teh results. If not
	// specified, a default sortBy has to be defined for every entity as a fallback.
	// E.g. for an entity like company, the default sortBy will be name, but a caller may 
	// choose t sprt by created date.
	sortBy  *string
}

// Cursor - a generic cursor for all entities
// Considering that the guidance is to use UUID as the the unique id for every entity in the platform,
// UIID is not inherently sortable. Hence, a combination of unique id and another field (which can be sorted upon)
// has to be used to make the cursor.
// E,g. for an entity like company, UniqueID will be UUID and OrderingKey will be company name.
// UniqueId and OrderingKey combination is used to infer where to start the next page from.
type Cursor struct {
	UniqueID    string `json:"uniqueId"`
	OrderingKey string `json:"orderingKey"`
}
```

### Interfaces
```go
// Pageable: An interface which needs to be implemnted by an entity which needs pagination
type Pageable interface {
	// returns the uuid for the last record from the slice of records which
	//is the pageable entity
	UniqueVal() *string

	// returns the default sorting field value for the last record from the
	// slice of records which is the pageable entity
	SortingVal() *string
}

```
**A pagination example**
```go

const (
	companyID   = "01d3b488-b123-4411-8cd4-7955d4b5a412"
	companyName = "avengers4"
	createdDate = "2021-05-06T14:49:37.871695Z"
)

// a map of fields in json vs db column names
var fieldMapper = map[string]string{
	"name":        "name",
	"id":          "id",
	"createdDate": "created_date",
}

//convertToSQLField : a mapper to whitelist the columns allowed in query
func convertToSQLField(key string) string {
	return fieldMapper[key]
}

```
**A pageable entity definition**
```go

// An entity to paginate
type Company struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	CreatedDate string `json:"createdDate"`
}

// A slice which implements the pageable interface
type Companies []*Company

// UniqueVal : Returns the unique value to be used in cursor for pagination.
func (cc Companies) UniqueVal() *string {
	return &cc[len(cc)-1].ID
}

// SortingVal : Returns the default sorting value for this entity to be used in cursor for pagination.
func (cc Companies) SortingVal() *string {
	//default sorting val
	return &cc[len(cc)-1].Name
}

// DropLastRecord : Drops the last record from the slice
func (cc Companies) DropLastRecord() pagination.Pageable {
	cc = cc[:len(cc)-1]
	return cc
}

// LastRecord : Returns the last record from the slice
func (cc Companies) LastRecord() interface{} {
	return *cc[len(cc)-1]
}

// Length : Returns the length of slice
func (cc Companies) Length() int {
	return len(cc)
}

```
**Getting a pagination filter**
```go

//getFilter : Gets pagination filter
func getFilter(u string) (*filter.Filter, error) {
	vals, _ := url.ParseQuery(u)
	limit, _ := strconv.Atoi(string(vals.Get("https://company-service/v1/companies?limit")))
	cursor := vals["cursor"]
	sortBy := vals["sortBy"]

	defaultSortBy := "name"
	companyByCompanyID := "id"

	start := time.Now()

	paginate := pagination.NewParams(limit, cursor[0], &sortBy[0])
	//handle pagination
	f, err := pagination.GetFilter(paginate, defaultSortBy, companyByCompanyID, nil,
		sql.GetConverter(), convertToSQLField)
	if err != nil {
		return nil, fmt.Errorf("GetByPartner | Failed to get pageFilter for params: %+v with error: %v", paginate, err)
	}

	elapsed := time.Since(start)
	fmt.Printf("Time taken | getFilter : %s\n", elapsed)

	return f, nil
}

```
**Paginatig the results**
```go

// paginateResults : will paginate the results returned and add a header for the next page link
func paginateResults(w http.ResponseWriter, r *http.Request, companies Companies, limit int, sortBy *string) (Companies, error) {

	start := time.Now()

	//append link in response header
	records, err := pagination.Paginate(w, *r, companies, limit, sortBy)
	if err != nil {
		return nil, fmt.Errorf("failed to paginate companies: %+v | error: %v", companies, err)
	}

	elapsed := time.Since(start)
	fmt.Printf("Time taken | paginateResults : %s\n", elapsed)

	return records.(Companies), nil

}

func main() {
	c := pagination.Cursor{
		UniqueID:    companyID,
		OrderingKey: createdDate,
	}

	//setting a mock cursor, limit and sortBy
	cursor, _ := c.Encode()
	limit := 2
	sortBy := "createdDate"

	expectedFilter := filter.New("(created_date,id) > (%v,%v) order by created_date limit %v", createdDate, companyID, strconv.Itoa(limit+1))

	u := `https://company-service/v1/companies?limit=%v&cursor=%v&sortBy=%v`

	ru := fmt.Sprintf(u, limit, cursor, sortBy)

	f, _ := getFilter(ru)

	if !(reflect.DeepEqual(f, expectedFilter)) {
		fmt.Printf("got: %v, want: %v", f, expectedFilter)
	}

	r, _ := http.NewRequest(http.MethodGet, u, nil)
	w := httptest.NewRecorder()

	//few dummy companies
	c1 := &Company{"1", "tes", "2021-07-07T17:14:53.906967433Z"}
	c2 := &Company{"2", "bor", "2021-07-07T17:14:53.906967433Z"}
	c3 := &Company{"3", "neuro", "2021-07-07T17:14:53.906967433Z"}

	dummyCompanies := Companies{c1, c2, c3}
	expectedCompanies := Companies{c1, c2}

	records, _ := paginateResults(w, r, dummyCompanies, 2, &sortBy)

	//expecting the first two records c1 and c2
	if !(reflect.DeepEqual(records, expectedCompanies)) {
		fmt.Printf("got: %v, want: %v", records, expectedCompanies)
	}

	//setting expectation for the next page link
	expectedCursor := pagination.Cursor{
		UniqueID:    c2.ID,
		OrderingKey: c2.CreatedDate,
	}
	expectedCursorEnc, _ := expectedCursor.Encode()
	expectedNextPageLink := fmt.Sprintf(u, limit, expectedCursorEnc, sortBy)

	//expecting next page link in the response header
	if !(reflect.DeepEqual(w.Header().Get("Link"), expectedNextPageLink)) {
		fmt.Printf("got: %v, want: %v", w.Header().Get("Link"), expectedNextPageLink)
	}
}

```

// Code generated by MockGen. DO NOT EDIT.
// Source: command.go

// Package command is a generated GoMock package.
package command

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	filter "gitlab.kksharmadevdev.com/platform/platform-common-lib/src/v6/filter"
)

// MockConverter is a mock of Converter interface.
type MockConverter struct {
	ctrl     *gomock.Controller
	recorder *MockConverterMockRecorder
}

// MockConverterMockRecorder is the mock recorder for MockConverter.
type MockConverterMockRecorder struct {
	mock *MockConverter
}

// NewMockConverter creates a new mock instance.
func NewMockConverter(ctrl *gomock.Controller) *MockConverter {
	mock := &MockConverter{ctrl: ctrl}
	mock.recorder = &MockConverterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConverter) EXPECT() *MockConverterMockRecorder {
	return m.recorder
}

// AND mocks base method.
func (m *MockConverter) AND(filters ...*filter.Filter) *filter.Filter {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range filters {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AND", varargs...)
	ret0, _ := ret[0].(*filter.Filter)
	return ret0
}

// AND indicates an expected call of AND.
func (mr *MockConverterMockRecorder) AND(filters ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AND", reflect.TypeOf((*MockConverter)(nil).AND), filters...)
}

// DoForCommandWithValue mocks base method.
func (m *MockConverter) DoForCommandWithValue(arg0 Command, arg1 func(string) string) (*filter.Filter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoForCommandWithValue", arg0, arg1)
	ret0, _ := ret[0].(*filter.Filter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DoForCommandWithValue indicates an expected call of DoForCommandWithValue.
func (mr *MockConverterMockRecorder) DoForCommandWithValue(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoForCommandWithValue", reflect.TypeOf((*MockConverter)(nil).DoForCommandWithValue), arg0, arg1)
}

// DoForCommandWithoutProperty mocks base method.
func (m *MockConverter) DoForCommandWithoutProperty(arg0 Command, arg1 func(string) string) (*filter.Filter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoForCommandWithoutProperty", arg0, arg1)
	ret0, _ := ret[0].(*filter.Filter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DoForCommandWithoutProperty indicates an expected call of DoForCommandWithoutProperty.
func (mr *MockConverterMockRecorder) DoForCommandWithoutProperty(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoForCommandWithoutProperty", reflect.TypeOf((*MockConverter)(nil).DoForCommandWithoutProperty), arg0, arg1)
}

// DoForCommandWithoutValue mocks base method.
func (m *MockConverter) DoForCommandWithoutValue(arg0 Command, arg1 func(string) string) (*filter.Filter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoForCommandWithoutValue", arg0, arg1)
	ret0, _ := ret[0].(*filter.Filter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DoForCommandWithoutValue indicates an expected call of DoForCommandWithoutValue.
func (mr *MockConverterMockRecorder) DoForCommandWithoutValue(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoForCommandWithoutValue", reflect.TypeOf((*MockConverter)(nil).DoForCommandWithoutValue), arg0, arg1)
}

// GetLimitFilter mocks base method.
func (m *MockConverter) GetLimitFilter(limit int) (*filter.Filter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLimitFilter", limit)
	ret0, _ := ret[0].(*filter.Filter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLimitFilter indicates an expected call of GetLimitFilter.
func (mr *MockConverterMockRecorder) GetLimitFilter(limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLimitFilter", reflect.TypeOf((*MockConverter)(nil).GetLimitFilter), limit)
}

// GetOrderByFilter mocks base method.
func (m *MockConverter) GetOrderByFilter(field string, mapper func(string) string) (*filter.Filter, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOrderByFilter", field, mapper)
	ret0, _ := ret[0].(*filter.Filter)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetOrderByFilter indicates an expected call of GetOrderByFilter.
func (mr *MockConverterMockRecorder) GetOrderByFilter(field, mapper interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrderByFilter", reflect.TypeOf((*MockConverter)(nil).GetOrderByFilter), field, mapper)
}

// OR mocks base method.
func (m *MockConverter) OR(filters ...*filter.Filter) *filter.Filter {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range filters {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "OR", varargs...)
	ret0, _ := ret[0].(*filter.Filter)
	return ret0
}

// OR indicates an expected call of OR.
func (mr *MockConverterMockRecorder) OR(filters ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OR", reflect.TypeOf((*MockConverter)(nil).OR), filters...)
}

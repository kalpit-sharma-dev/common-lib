// Package sql comprises the convertor that can be used
// to convert a Command to a Filter which consists of
// a sql query and a value as generated by the converter.
package sql

import (
	"fmt"
	"strconv"
	"strings"
	"sync"

	"gitlab.kksharmadevdev.com/platform/platform-common-lib/src/v6/filter"
	"gitlab.kksharmadevdev.com/platform/platform-common-lib/src/v6/filter/command"
)

// op : an operator.
type op string

const (
	errOperatorNotFound      string = "no matching operator found for %v"
	errFieldNotFound         string = "no matching field found for %v"
	errOperatorAlreadyExists string = "attempt to overwrite an existing operator, key: %v, value: %v with value %v"
	errUnexpectedCommand     string = "unexpected command received: %v"
	errUnexpectedMapper      string = "unexpected mapper received: %v"
)

const (
	stmtPlaceholder      = "%v"
	nestedFieldDelimiter = "."
	doubleQuote          = "\""
	likePattern          = "%%%v%%"
	inPattern            = "(%v)"
	queryTerminator      = ";"
	space                = " "
	multiColumnDelimiter = ","
)

const (
	lt      op = "<"
	le      op = "<="
	gt      op = ">"
	ge      op = ">="
	and     op = "and"
	or      op = "or"
	not     op = "!="
	eq      op = "="
	null    op = "is null"
	nonNull op = "is not null"
	lhs     op = "("
	rhs     op = ")"
	like    op = " like "
	in      op = "in"
	limit   op = "limit"
	orderBy op = "order by"
)

var (
	// map of command operators vs SQL operators.
	operators map[string]string
	doOnce    sync.Once
	sc        *SQLconverter
)

// SQLconverter : Converts command to corresponding SQL syntax.
type SQLconverter struct{}

// GetConverter : Get a SQL converter singleton.
func GetConverter() *SQLconverter {
	doOnce.Do(func() {
		sc = &SQLconverter{}
	})

	return sc
}

func init() {
	operators = make(map[string]string)

	AddOperator(command.And, and)
	AddOperator(command.Or, or)
	AddOperator(command.Gt, gt)
	AddOperator(command.Ge, ge)
	AddOperator(command.Lt, lt)
	AddOperator(command.Le, le)
	AddOperator(command.LHS, lhs)
	AddOperator(command.RHS, rhs)
	AddOperator(command.Not, not)
	AddOperator(command.Eq, eq)
	AddOperator(command.Null, null)
	AddOperator(command.NonNull, nonNull)
	AddOperator(command.Like, like)
	AddOperator(command.In, in)
	AddOperator(command.Limit, limit)
	AddOperator(command.OrderBy, orderBy)
}

// AddOperator : adds a mapping of operator from Command to SQL
func AddOperator(key command.Op, value op) {
	if op, ok := operators[string(key)]; ok {
		//nolint:goerr113
		panic(fmt.Errorf(errOperatorAlreadyExists, key, op, value))
	}

	operators[string(key)] = string(value)
}

// Convert : converts a command to corresponding SQL.
func Convert(key string) string {
	return operators[key]
}

// getField : gets the corresponding internal field name
// for the supplied filter property.
func (s *SQLconverter) getField(key string, mapper func(string) string) (string, int) {
	//this may be a multi column sub query, hence splitting based on ","
	keys := strings.Split(key, multiColumnDelimiter)

	var field string
	for _, k := range keys {
		if mapper(k) == "" {
			return "", 0
		}

		field = field + mapper(k) + multiColumnDelimiter
	}

	return field[:len(field)-1], len(keys)
}

func stripDoubleQuotes(val string) string {
	if len(strings.TrimSpace(val)) == 0 {
		return val
	}

	if val[:1] == doubleQuote && val[len(val)-1:] == doubleQuote {
		val = val[1 : len(val)-1]
	}

	return val
}

// DoForCommandWithoutValue : A visitor Do method for a command that
// does not have a value.
func (s *SQLconverter) DoForCommandWithoutValue(c command.Command, mapper func(string) string) (*filter.Filter, error) {
	if c.Value() != "" {
		return nil, nil
	}
	key := Convert(c.Operator())
	if key == "" {
		//nolint:goerr113
		return nil, fmt.Errorf(errOperatorNotFound, c.Operator())
	}
	switch c.Operator() {
	case string(command.Null), string(command.NonNull):
		return filter.New(mapper(c.Property()) + " " + key), nil
	default:
		return filter.New(key), nil
	}
}

// DoForCommandWithoutProperty : A visitor Do method for a command that
// does not have a property. E.g. LIMIT, ORDER BY
func (s *SQLconverter) DoForCommandWithoutProperty(c command.Command, mapper func(string) string) (*filter.Filter, error) {
	if c.Property() == "" {

		key := Convert(c.Operator())
		if key == "" {
			//nolint:goerr113
			return nil, fmt.Errorf(errOperatorNotFound, c.Operator())
		}

		if c.Operator() == string(command.OrderBy) {

			// If this is the order by handling flow, mapper is a must
			if mapper == nil {
				return nil, fmt.Errorf(errUnexpectedMapper, nil)
			}

			sortField, sortOrder := getSortFieldAndOrderFromCommandValue(c.Value())
			//count returned by getField is ignored for now
			//we can consider it if we have a use case where we would want to pass
			// comma delimited fields to DoForCommandWithoutProperty
			values, _ := s.getField(sortField, mapper)
			if values == "" {
				//nolint:goerr113
				return nil, fmt.Errorf(errFieldNotFound, sortField)
			}

			// When sorting in postgres, you must interpolate the sorting column name directly into the SQL.
			// You simply cannot use a positional argument in place of the column's name.
			// See: https://www.postgresql.org/message-id/1421875206968-5834948.post@n5.nabble.com

			key = addValuesAndSortOrderToKey(key, values, sortOrder)
			return filter.New(key), nil
		} else {
			key = key + " %v"
			return filter.New(key, c.Value()), nil
		}
	}

	return nil, fmt.Errorf(errUnexpectedCommand, c)
}

// getSortFieldAndOrderFromCommandValue : Separates the sortBy value into a field (id, name, etc.) and order (asc, desc)
func getSortFieldAndOrderFromCommandValue(s string) (string, string) {
	sortFieldsAndSortOrder := strings.Split(s, " ")
	fields := sortFieldsAndSortOrder[0]
	order := ""

	if len(sortFieldsAndSortOrder) > 1 {
		order = strings.ToLower(sortFieldsAndSortOrder[1])

		if order != "asc" && order != "desc" {
			order = "asc"
		}
	}

	return fields, order
}

func addValuesAndSortOrderToKey(key string, values string, sortOrder string) string {
	sortValues := strings.Split(values, ",")
	for _, val := range sortValues {
		if sortOrder != "" {
			key = key + " " + val + " " + sortOrder + ","
		} else {
			key = key + " " + val + ","
		}
	}

	return key[:len(key)-1]
}

// DoForCommandWithValue : A visitor Do method for a command that
// has a value.
// This function validates the property and the operator and returns
// an error if mapping not found.
func (s *SQLconverter) DoForCommandWithValue(c command.Command, mapper func(string) string) (*filter.Filter, error) {
	property, count := s.getField(c.Property(), mapper)
	if property == "" {
		//nolint:goerr113
		return nil, fmt.Errorf(errFieldNotFound, c.Property())
	}

	operator := Convert(c.Operator())
	if operator == "" {
		//nolint:goerr113
		return nil, fmt.Errorf(errOperatorNotFound, c.Operator())
	}

	val := stripDoubleQuotes(c.Value())

	switch c.Operator() {

	case string(command.Like):
		val = fmt.Sprintf(likePattern, val)
		key := property + space + operator + space + stmtPlaceholder
		return filter.New(key, val), nil

	case string(command.In):
		tokens := strings.Split(val, ",")
		var vals []interface{}
		placeholders := ""
		for _, token := range tokens {
			placeholders = placeholders + stmtPlaceholder + ","
			vals = append(vals, token)
		}
		placeholders = placeholders[:len(placeholders)-1]
		placeholders = fmt.Sprintf(inPattern, placeholders)
		key := property + space + operator + space + placeholders
		return filter.New(key, vals...), nil

	default:
		var placeholders string
		for i := 0; i < count; i++ {
			placeholders = placeholders + stmtPlaceholder + multiColumnDelimiter
		}
		//truncate the extra multiColumnDelimiter in the end
		placeholders = placeholders[:len(placeholders)-len(multiColumnDelimiter)]

		key := "(" + property + ")" + space + operator + space + "(" + placeholders + ")"
		return filter.New(key, val), nil
	}
}

// Useful for creating operators like AND, OR, +, -, etc
func (s *SQLconverter) joinFilters(filters []*filter.Filter, delimeter string) *filter.Filter {
	if len(filters) == 0 {
		return filter.New("")
	}
	newFilter := *filters[0]
	for i, f := range filters {
		// Skip the first filter, because it's what newFilter started out as
		if i == 0 {
			continue
		}
		newFilter = newFilter.Add(filter.New(
			delimeter+" "+f.GetQuery(),
			f.GetValues()...,
		))
	}
	return &newFilter
}

// AND : Allows you to AND together several filters
// If you have filters f1, f2, and f3, this function produces SQL like "f1 AND f2 AND f3"
func (s *SQLconverter) AND(filters ...*filter.Filter) *filter.Filter {
	return s.joinFilters(filters, string(command.And))
}

// OR: Allows you to OR together several filters
// If you have filters f1, f2, and f3, this function produces SQL like "f1 OR f2 OR f3"
func (s *SQLconverter) OR(filters ...*filter.Filter) *filter.Filter {
	return s.joinFilters(filters, string(command.Or))
}

// GetLimitFilter : a useful method to quickly get a LIMIT filter
func (s *SQLconverter) GetLimitFilter(limit int) (*filter.Filter, error) {
	cmd := command.New("", string(command.Limit), strconv.Itoa(limit))
	lf, err := s.DoForCommandWithoutProperty(cmd, nil)
	if err == nil {
		lf.ShouldAnd = false
	}
	return lf, err
}

// GetOrderByFilter : a useful method to quickly get an ORDER BY filter
func (s *SQLconverter) GetOrderByFilter(field string, mapper func(string) string) (*filter.Filter, error) {
	cmd := command.New("", string(command.OrderBy), field)
	of, err := s.DoForCommandWithoutProperty(cmd, mapper)
	if err == nil {
		of.ShouldAnd = false
	}
	return of, err
}

// AppendFilterToWhereClause : returns query with filter appended
func getQuery(query string, f filter.Filter, start int) string {
	placeholders := make([]interface{}, len(f.GetValues()))
	for i := 0; i < len(f.GetValues()); i++ {
		placeholders[i] = fmt.Sprintf("$%v", start)
		start++
	}
	where := fmt.Sprintf(f.GetQuery(), placeholders...)
	where = where + queryTerminator

	if f.ShouldAnd {
		query = query[:len(query)-1] + " AND " + where
		return query
	}

	query = query[:len(query)-1] + " " + where
	return query
}

// AppendFilterToWhereClause : appends the filter to SQL query where clause
func AppendFilterToWhereClause(query string, filter *filter.Filter, args []interface{}) (string, []interface{}) {
	q := query

	if filter != nil {
		q = getQuery(q, *filter, len(args)+1)
		args = append(args, filter.GetValues()...)
	}
	return q, args
}

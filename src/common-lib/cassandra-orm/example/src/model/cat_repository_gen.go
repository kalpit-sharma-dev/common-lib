// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package model

import (
	"sync"
	"time"

	"github.com/gocql/gocql"
	"github.com/scylladb/gocqlx/qb"
	db "gitlab.kksharmadevdev.com/platform/platform-common-lib/src/v6/cassandra-orm"
)

const (
	catBaseTableName = "cats"
	catsByAge        = "cats_by_age"
	catsByName       = "cats_by_name"
)

var (
	catKeyColumns = []string{IDColumn, AgeColumn}
	catViewTables = map[string][]string{
		catsByAge:  {AgeColumn, IDColumn},
		catsByName: {NameColumn, AgeColumn, IDColumn},
	}

	catsRepository *CatRepository
	initCats       sync.Once
)

// CatRepository interface
type CatRepository struct {
	base db.Base
}

// Cats singleton, thread-safe, returns pointer to Cats repository
func Cats() *CatRepository {
	initCats.Do(func() {
		catsRepository = &CatRepository{base: db.NewBase(
			&Cat{},
			catBaseTableName,
			catKeyColumns,
			catViewTables,
		)}
	})
	return catsRepository
}

// Get return item
func (r *CatRepository) Get(keyCols ...interface{}) (*Cat, error) {
	cat := new(Cat)
	if err := r.base.Get(cat, keyCols...); err != nil {
		return nil, err
	}
	return cat, nil
}

// All returns slice of Cats
func (r *CatRepository) All() ([]*Cat, error) {
	var cats []*Cat
	if err := r.base.All(&cats); err != nil {
		return nil, err
	}
	return cats, nil
}

// Add check/generates ID and inserts item
// nolint:interfacer
func (r *CatRepository) Add(item *Cat) error {
	return r.base.Add(item)
}

// AddWithTTL check/generates ID and inserts item with ttl
// nolint:interfacer
func (r *CatRepository) AddWithTTL(item *Cat, ttl time.Duration) error {
	return r.base.AddWithTTL(item, ttl)
}

// Update item in repository
// nolint:interfacer
func (r *CatRepository) Update(item *Cat) error {
	return r.base.Update(item)
}

// UpdateWithTTL item in repository with ttl
// nolint:interfacer
func (r *CatRepository) UpdateWithTTL(item *Cat, ttl time.Duration) error {
	return r.base.UpdateWithTTL(item, ttl)
}

// Delete item from repository
// nolint:interfacer
func (r *CatRepository) Delete(item *Cat) error {
	return r.base.Delete(item)
}

// AddWithBatch adds all queries to batch
// nolint:interfacer
func (r *CatRepository) AddWithBatch(batch *gocql.Batch, item *Cat) error {
	return r.base.AddWithBatch(batch, item)
}

// AddWithBatchAndTTL adds all queries with ttl to batch
// nolint:interfacer
func (r *CatRepository) AddWithBatchAndTTL(batch *gocql.Batch, item *Cat, ttl time.Duration) error {
	return r.base.AddWithBatchAndTTL(batch, item, ttl)
}

// UpdateWithBatch adds all queries to batch
// nolint:interfacer
func (r *CatRepository) UpdateWithBatch(batch *gocql.Batch, item *Cat) error {
	return r.base.UpdateWithBatch(batch, item)
}

// UpdateWithBatchAndTTL adds all queries with ttl to batch
// nolint:interfacer
func (r *CatRepository) UpdateWithBatchAndTTL(batch *gocql.Batch, item *Cat, ttl time.Duration) error {
	return r.base.UpdateWithBatchAndTTL(batch, item, ttl)
}

// DeleteWithBatch adds all queries to batch
// nolint:interfacer
func (r *CatRepository) DeleteWithBatch(batch *gocql.Batch, item *Cat) error {
	return r.base.DeleteWithBatch(batch, item)
}

// GetByID returns item by @id or error if item doesn't exists in repository
func (r *CatRepository) GetByID(id gocql.UUID) (*Cat, error) {
	return r.Get(id)
}

// GetByIDs returns slice of cats by slice of ids
func (r *CatRepository) GetByIDs(ids ...gocql.UUID) ([]*Cat, error) {
	var cats []*Cat
	queryBuilder := qb.Select(r.base.Table()).Where(
		qb.In(r.base.Quote(r.base.Keys()[0])),
	)

	err := r.base.QuerySelect(&cats, queryBuilder, map[string]interface{}{
		r.base.Quote(r.base.Keys()[0]): ids,
	})
	return cats, err
}

// GetRows returns slice of Cats filtered by received keys
func (r *CatRepository) GetRows(keyCols ...interface{}) ([]*Cat, error) {
	var cats []*Cat
	if err := r.base.All(&cats, keyCols...); err != nil {
		return nil, err
	}
	return cats, nil
}

// GetCatsByAge returns item from 'cats_by_age' table
func (r *CatRepository) GetCatsByAge(keyCols ...interface{}) (*Cat, error) {
	item := new(Cat)
	if err := r.base.GetFromTable(catsByAge, item, keyCols...); err != nil {
		return nil, err
	}
	return item, nil
}

// AllCatsByAge returns all items from 'cats_by_age' table
func (r *CatRepository) AllCatsByAge(keyCols ...interface{}) ([]*Cat, error) {
	var items []*Cat
	if err := r.base.AllFromTable(catsByAge, &items, keyCols...); err != nil {
		return nil, err
	}
	return items, nil
}

// GetCatsByName returns item from 'cats_by_name' table
func (r *CatRepository) GetCatsByName(keyCols ...interface{}) (*Cat, error) {
	item := new(Cat)
	if err := r.base.GetFromTable(catsByName, item, keyCols...); err != nil {
		return nil, err
	}
	return item, nil
}

// AllCatsByName returns all items from 'cats_by_name' table
func (r *CatRepository) AllCatsByName(keyCols ...interface{}) ([]*Cat, error) {
	var items []*Cat
	if err := r.base.AllFromTable(catsByName, &items, keyCols...); err != nil {
		return nil, err
	}
	return items, nil
}
